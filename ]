from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
import sys
import glob
import matplotlib.gridspec as gridspec
from mpl_toolkits.mplot3d import Axes3D
from nfft import nfft

#set up plotting environment
fig = plt.figure(figsize=(20,10))


#Define 3d/2d plotting


col = 'C0'
fs = 20
d = 2


if (d == 3):
    ax1 = plt.subplot2grid((1,1), (0,0),projection='3d')
elif  (d == 2):
    ax1 = plt.subplot2grid((1,2), (0,0))
    ax2 = plt.subplot2grid((1,2), (0,1))



#PLOT MPD TRAJECTORY

MPDfile = '/unsafe/tok2/GravWaves/Trajectory.txt'


data1 = np.loadtxt(MPDfile)
x = data1[:,0]
y = data1[:,1]
z = data1[:,2]


#theta = 0
hplus1 = data1[:,3]
hcross1 = data1[:,4]

#theta = pi/4
hplus2 = data1[:,5]
hcross2 = data1[:,6]


#theta = pi/2
hplus3 = data1[:,7]
hcross3 = data1[:,8]


t = data1[:,9]
r = data1[:,11]


ax1.plot(t,hplus1)



n = 10*len(t)
newt = np.linspace(t[0],t[-1],n)
newh = np.interp(newt,t,hplus1)
dt = newt[1] - newt[0]
t0 = newt[0]

ax1.scatter(newt,newh)










g = np.fft.fft(newh)
w = np.fft.fftfreq(newt.size)*2*np.pi/dt
g *= dt*np.exp(-complex(0,1)*w*t0)/(np.sqrt(2*np.pi))


ax2.plot(w,g)

ax2.set_yscale('log')
plt.show()
sys.exit()

#Discretize for the continuous FT









#Example function
t0 = 0.0
dt=0.001
t = np.arange(0,100,dt)



f = np.exp(-np.pi*t**2)


#FT
g = np.fft.fft(f)
w = np.fft.fftfreq(f.size)*2*np.pi/dt
g *= dt*np.exp(-complex(0,1)*w*t0)/(np.sqrt(2*np.pi))

#ax1.plot(t,f)
ax2.plot(w/(2*np.pi),g*np.sqrt(2*np.pi))

plt.show()
sys.exit()







#Interpolate the t-h data so that it is regularly sampled,correcting for adaptive RK
n = 1000*len(t)
newt = np.linspace(t[0],t[-1],n)
newh = np.interp(newt,t,hplus1)
dt = newt[1] - newt[0]
t0 = newt[0]

#Compute the Fourier transform via numpys FFT
g = np.fft.fft(newh)
#w = np.fft.fftfreq(newt.size)*2*np.pi/dt
w = np.linspace(1e-6,1,newt.size)*2*np.pi/dt

#Discretize for the continuous FT
g *= dt*np.exp(-complex(0,1)*w*t0)/(np.sqrt(2*np.pi))


ax1.plot(w,g)
f = w/(2*np.pi)
gf = g*np.sqrt(2*np.pi)

print (f)
ax1.set_xscale('log')
plt.show()


sys.exit()























fc = data1[0,10]


fstart = 1e-6
fend = 10
f = np.logspace(np.log10(fstart),np.log10(fend),500)



#y = np.fft.rfft(hplus1)
#print (len(y), len(hplus1))


#ax2.plot(abs(y), abs(y))
#plt.show()
#sys.exit()



N = len(hplus1)
hf = []
for i in np.arange(len(f)):
      
    Xk = 0
    fi = f[i]
    ti = t[i]
  
    for n in np.arange(N):
        pn = n/N
        Xk += hplus1[n]*np.exp(-2*np.pi*1j*i*pn)
        
            
    hf.extend([abs(Xk)])


'''
hfstar = np.conj(hf)


SNR = 0

for i in np.arange(len(f)):
    fi = f[i]
    h1 = hf[i]
    h2 = hfstar[i]



    L = 2.5 * 1e9
    Poms = (1.5e-11)**2 * (1+  (2e-3/fi)**4)
    Pacc = (3e-15)**2 * (1+(0.4e-3/fi)**2)*(1+(fi/8e-3)**4)
    fstar = 19.09e-3
    Sc = 0
    S = 10/(3*L**2) * (Poms + 4*Pacc/(2*np.pi*fi)**4) * (1+ 6/10 * (fi/fstar)**2) + Sc


    SNR += 2*(abs((h1*h2)/(S)))



print (np.sqrt(2*SNR))
'''








if (d == 3):
    ax1.plot(x,y,z)
    ax1.scatter(0,0,0,c='r')
elif (d==2):
    ax1.plot(x,y,c='C0')
    ax2.plot(t,hplus1,c='C0')
    #ax2.plot(f,np.abs(hf),c='C0')
    #ax2.set_xscale('log')
    #ax2.set_yscale('log')
    #ax2.axvline(fc)
    ax1.set_xlabel(r'$ x [\rm r_g]$',fontsize = fs)
    ax1.scatter(0,0,c='r')
plt.show()








plt.show()




